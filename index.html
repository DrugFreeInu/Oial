<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Presence</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: radial-gradient(circle at center, #020812, #000);
  overflow: hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w,h;
function resize(){
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

// ─── EYE ─────────────────────────────
const eye = {
  x: w*0.5,
  y: h*0.5,
  rx: 32,
  ry: 14,
  blink: 1,
  blinkTarget: 1,
  nextBlink: performance.now() + 8000 + Math.random()*7000
};

// ─── TRAILS ──────────────────────────
const trails = [];
const MAX_TRAILS = 360;

function spawnTrail(x,y,type){
  trails.push({
    x, y,
    r: 12 + Math.random()*18,   // MUCH wider
    a: 0.12 + Math.random()*0.08,
    life: 1,
    type,
    vy: 0.4 + Math.random()*0.8,
    angle: Math.random()*Math.PI*2,
    radius: 28 + Math.random()*28,
    driftX: (Math.random()-0.5)*0.4
  });
  if(trails.length > MAX_TRAILS) trails.shift();
}

// ─── MOTION PATH ─────────────────────
let path = {};
let resting = true;
let restUntil = 0;

function newPath(){
  const sx = eye.x;
  const sy = eye.y;
  const ex = w * (0.18 + Math.random()*0.64);
  const ey = h * (0.38 + Math.random()*0.24);
  const dx = ex - sx;

  path = {
    sx, sy, ex, ey,
    c1x: sx + dx * 0.25,
    c1y: sy - (30 + Math.random()*60),
    c2x: sx + dx * 0.75,
    c2y: ey - (20 + Math.random()*50),
    start: performance.now(),
    dur: 1400 + Math.random()*1200
  };
  resting = false;
}

// cubic bezier
function bezier(t,p0,p1,p2,p3){
  const u = 1-t;
  return (
    u*u*u*p0 +
    3*u*u*t*p1 +
    3*u*t*t*p2 +
    t*t*t*p3
  );
}

// ─── DRAW TRAILS ─────────────────────
function drawTrails(){
  for(let i=trails.length-1;i>=0;i--){
    const p = trails[i];
    p.life *= 0.97;

    if(p.type === "fall"){
      p.y += p.vy;
      p.vy += 0.025;
      p.x += p.driftX;
    } else {
      p.angle += 0.012;
      p.x = eye.x + Math.cos(p.angle) * p.radius;
      p.y = eye.y + Math.sin(p.angle) * p.radius;
    }

    // soft gradient particle
    const g = ctx.createRadialGradient(
      p.x, p.y, 0,
      p.x, p.y, p.r * p.life
    );
    g.addColorStop(0, `rgba(255,180,130,${p.a * p.life})`);
    g.addColorStop(0.6, `rgba(255,160,110,${p.a * p.life * 0.5})`);
    g.addColorStop(1, "rgba(255,160,110,0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI*2);
    ctx.fill();

    if(p.life < 0.04 || p.y > h + 80) trails.splice(i,1);
  }
}

// ─── DRAW EYE ─────────────────────────
function drawEye(){
  ctx.save();
  ctx.translate(eye.x, eye.y);
  ctx.scale(1, eye.blink);

  const g = ctx.createRadialGradient(0,0,0,0,0,36);
  g.addColorStop(0,"rgba(130,190,240,0.16)");
  g.addColorStop(1,"rgba(130,190,240,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.ellipse(0,0,eye.rx*1.7,eye.ry*1.7,0,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "rgba(215,235,250,0.85)";
  ctx.beginPath();
  ctx.ellipse(0,0,eye.rx,eye.ry,0,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "rgba(90,130,170,0.85)";
  ctx.beginPath();
  ctx.arc(0,0,6,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "rgba(15,25,35,0.95)";
  ctx.beginPath();
  ctx.arc(0,0,2.8,0,Math.PI*2);
  ctx.fill();

  ctx.restore();
}

// ─── LOOP ─────────────────────────────
function loop(){
  ctx.clearRect(0,0,w,h);
  const now = performance.now();

  if(!resting){
    const t = Math.min((now - path.start)/path.dur, 1);
    const ease = t*t*(3 - 2*t);
    eye.x = bezier(ease,path.sx,path.c1x,path.c2x,path.ex);
    eye.y = bezier(ease,path.sy,path.c1y,path.c2y,path.ey);

    spawnTrail(eye.x, eye.y, "fall");

    if(t >= 1){
      resting = true;
      restUntil = now + 1600 + Math.random()*2200;
    }
  } else {
    if(trails.length < MAX_TRAILS * 0.7){
      spawnTrail(eye.x, eye.y, "orbit");
    }
    if(now > restUntil) newPath();
  }

  // blink only while resting
  if(resting){
    if(now > eye.nextBlink && eye.blinkTarget === 1){
      eye.blinkTarget = 0;
    }
    if(eye.blinkTarget === 0 && eye.blink < 0.05){
      eye.blinkTarget = 1;
      eye.nextBlink = now + 8000 + Math.random()*7000;
    }
  }
  eye.blink += (eye.blinkTarget - eye.blink) * 0.14;

  drawTrails();
  drawEye();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
