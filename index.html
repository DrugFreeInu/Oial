<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>a-eye-magic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: radial-gradient(circle at center, #020812, #000);
  overflow: hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w,h;
function resize(){
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* ───────── TIME ───────── */
let T = 0;

/* ───────── EYE GEOMETRY ───────── */
const eye = {
  x: () => w * 0.5,
  y: () => h * 0.45,

  // inner eye
  innerRX: 46,
  innerRY: 18,

  // SINGLE dashed ring band
  ringInner: 72,
  ringOuter: 98,

  blink: 1,
  blinkTarget: 1,
  nextBlink: performance.now() + 6000 + Math.random()*6000
};

/* ───────── LETTER FIELD (INSIDE THE ONE RING) ───────── */
const CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?!@#$";
const letters = [];
const LETTER_COUNT = 40;

function initLetters(){
  letters.length = 0;
  for(let i=0;i<LETTER_COUNT;i++){
    letters.push({
      a: Math.random() * Math.PI * 2,
      r: eye.ringInner + Math.random() * (eye.ringOuter - eye.ringInner),
      va: (Math.random() - 0.5) * 0.002,
      vr: (Math.random() - 0.5) * 0.35,
      rot: Math.random() * Math.PI * 2,
      ch: CHARS[Math.floor(Math.random() * CHARS.length)]
    });
  }
}
initLetters();

function scrambleLetters(){
  letters.forEach(l=>{
    l.va += (Math.random() - 0.5) * 0.004;
    l.vr += (Math.random() - 0.5) * 0.6;
    l.ch = CHARS[Math.floor(Math.random() * CHARS.length)];
  });
}

/* ───────── LETTER CHAOS (CLIPPED TO RING BAND) ───────── */
function drawLetters(){
  ctx.save();
  ctx.translate(eye.x(), eye.y());

  // annulus clip (THIS defines the ring, nothing else)
  ctx.beginPath();
  ctx.arc(0,0,eye.ringOuter,0,Math.PI*2);
  ctx.arc(0,0,eye.ringInner,0,Math.PI*2,true);
  ctx.clip();

  ctx.font = "14px monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  letters.forEach(l=>{
    l.a += l.va;
    l.r += l.vr;
    l.rot += 0.01;

    // containment
    if(l.r < eye.ringInner){ l.r = eye.ringInner; l.vr *= -1; }
    if(l.r > eye.ringOuter){ l.r = eye.ringOuter; l.vr *= -1; }

    const x = Math.cos(l.a) * l.r;
    const y = Math.sin(l.a) * l.r;

    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(l.rot);
    ctx.fillStyle = "rgba(120,255,180,0.7)";
    ctx.shadowColor = "rgba(120,255,180,0.4)";
    ctx.shadowBlur = 8;
    ctx.fillText(l.ch,0,0);
    ctx.restore();
  });

  ctx.restore();
}

/* ───────── SINGLE DASHED RING (ONLY RING DRAWN) ───────── */
function drawRing(){
  ctx.save();
  ctx.translate(eye.x(), eye.y());

  ctx.setLineDash([8,8]);
  ctx.beginPath();
  ctx.arc(0,0,(eye.ringInner + eye.ringOuter)/2,0,Math.PI*2);
  ctx.strokeStyle = "rgba(120,255,180,0.35)";
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.restore();
}

/* ───────── INNER EYE ───────── */
function drawInnerEye(){
  ctx.save();
  ctx.translate(eye.x(), eye.y());

  const rx = eye.innerRX * eye.blink;
  const ry = eye.innerRY * eye.blink;

  ctx.beginPath();
  ctx.ellipse(0,0,rx,ry,0,0,Math.PI*2);
  ctx.strokeStyle = "rgba(120,255,180,0.6)";
  ctx.lineWidth = 1.6;
  ctx.shadowColor = "rgba(120,255,180,0.45)";
  ctx.shadowBlur = 12;
  ctx.stroke();

  ctx.restore();
}

/* ───────── LOOP ───────── */
function loop(){
  ctx.clearRect(0,0,w,h);
  T += 0.003;

  // blink
  if(performance.now() > eye.nextBlink && eye.blinkTarget === 1){
    eye.blinkTarget = 0;
    scrambleLetters();
  }
  if(eye.blinkTarget === 0 && eye.blink < 0.05){
    eye.blinkTarget = 1;
    eye.nextBlink = performance.now() + 6000 + Math.random()*6000;
  }
  eye.blink += (eye.blinkTarget - eye.blink) * 0.08;

  drawLetters();   // chaos inside ring
  drawRing();      // ONE ring
  drawInnerEye();  // pupil

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
