<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>a-eye-magic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: radial-gradient(circle at center, #020812, #000);
  overflow: hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w, h;
function resize(){
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ TIME â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let T = 0;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ PRESENCE â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const eye = {
  x: w * 0.5,
  y: h * 0.45,
  radius: 62,
  blink: 1,
  blinkTarget: 1,
  nextBlink: performance.now() + 6000 + Math.random()*6000
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ AIR PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const particles = [];
const MAX_P = 260;

function spawnBlinkParticles(){
  const count = 18 + Math.floor(Math.random()*10);

  for(let i=0;i<count;i++){
    particles.push({
      x: eye.x + (Math.random()-0.5)*20,
      y: eye.y + (Math.random()-0.5)*8,
      vy: 0.05 + Math.random()*0.09,   // slow settle
      vx: (Math.random()-0.5)*0.15,
      r: 14 + Math.random()*22,
      a: 0.10,
      life: 1
    });
  }

  if(particles.length > MAX_P){
    particles.splice(0, particles.length - MAX_P);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ MOTION PATH â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let path = {};
let resting = true;
let restUntil = 0;

function newPath(){
  const sx = eye.x;
  const sy = eye.y;
  const ex = w * (0.18 + Math.random()*0.64);
  const ey = h * (0.35 + Math.random()*0.25);
  const dx = ex - sx;

  path = {
    sx, sy, ex, ey,
    c1x: sx + dx * 0.25,
    c1y: sy - (40 + Math.random()*60),
    c2x: sx + dx * 0.75,
    c2y: ey - (30 + Math.random()*50),
    start: performance.now(),
    dur: 1600 + Math.random()*1400
  };
  resting = false;
}

function bezier(t,p0,p1,p2,p3){
  const u = 1-t;
  return (
    u*u*u*p0 +
    3*u*u*t*p1 +
    3*u*t*t*p2 +
    t*t*t*p3
  );
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ DRAW PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function drawParticles(){
  for(let i = particles.length-1; i >= 0; i--){
    const p = particles[i];
    p.life *= 0.97;

    p.x += p.vx + Math.sin(p.y*0.02 + T)*0.05;
    p.y += p.vy;

    ctx.fillStyle = `rgba(120,255,180,${p.a * p.life})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI*2);
    ctx.fill();

    if(p.life < 0.04 || p.y > h + 80){
      particles.splice(i,1);
    }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ DRAW INNER EYE GLOW â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function drawEyeGlow(){
  ctx.save();
  ctx.translate(eye.x, eye.y);

  const pulse = eye.blink; // blink controls aperture

  const grad = ctx.createRadialGradient(0,0,0,0,0,48);
  grad.addColorStop(0, "rgba(120,255,180,0.35)");
  grad.addColorStop(0.6, "rgba(120,255,180,0.18)");
  grad.addColorStop(1, "rgba(120,255,180,0)");

  ctx.fillStyle = grad;
  ctx.scale(1.6 * pulse, 0.7 * pulse);
  ctx.beginPath();
  ctx.arc(0,0,32,0,Math.PI*2);
  ctx.fill();

  ctx.restore();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ DRAW FRACTURED RING â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function drawRing(){
  ctx.save();
  ctx.translate(eye.x, eye.y);

  const breathe = Math.sin(T * 0.6) * 6;
  const twist = Math.sin(T * 0.35) * 0.25;
  ctx.rotate(twist);

  const segments = 22;

  for(let i = 0; i < segments; i++){
    if(Math.random() < 0.38) continue;

    const a0 = (i / segments) * Math.PI*2;
    const a1 = a0 + (Math.PI*2/segments) * (0.5 + Math.random()*0.5);

    ctx.beginPath();
    ctx.arc(
      0,0,
      eye.radius + breathe + Math.sin(T*0.8+i)*2,
      a0,a1
    );

    ctx.strokeStyle = "rgba(120,255,180,0.45)";
    ctx.lineWidth = 2;
    ctx.shadowColor = "rgba(120,255,180,0.35)";
    ctx.shadowBlur = 14;
    ctx.stroke();
  }

  ctx.restore();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function loop(){
  ctx.clearRect(0,0,w,h);
  T += 0.003;

  // movement (independent of particles)
  if(!resting){
    const t = Math.min((performance.now() - path.start)/path.dur, 1);
    const ease = t*t*(3 - 2*t);

    eye.x = bezier(ease,path.sx,path.c1x,path.c2x,path.ex);
    eye.y = bezier(ease,path.sy,path.c1y,path.c2y,path.ey);

    if(t >= 1){
      resting = true;
      restUntil = performance.now() + 1800 + Math.random()*2400;
    }
  } else if(performance.now() > restUntil){
    newPath();
  }

  // blink logic
  if(performance.now() > eye.nextBlink && eye.blinkTarget === 1){
    eye.blinkTarget = 0;
    spawnBlinkParticles(); // ðŸ”¥ PARTICLES FROM BLINK
  }

  if(eye.blinkTarget === 0 && eye.blink < 0.05){
    eye.blinkTarget = 1;
    eye.nextBlink = performance.now() + 6000 + Math.random()*6000;
  }

  eye.blink += (eye.blinkTarget - eye.blink) * 0.08;

  drawParticles();
  drawEyeGlow();
  drawRing();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
