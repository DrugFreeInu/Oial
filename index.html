<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>a-eye-magic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: radial-gradient(circle at center, #020812, #000);
  overflow: hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w,h;
function resize(){
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* ───────── TIME ───────── */
let T = 0;

/* ───────── EYE ───────── */
const eye = {
  x: w * 0.5,
  y: h * 0.45,
  radius: 62,
  blink: 1,
  blinkTarget: 1,
  nextBlink: performance.now() + 6000 + Math.random()*6000
};

/* ───────── FRACTURE MEMORY (IMPORTANT) ───────── */
const segments = 24;
const fractures = Array.from({length: segments}, (_,i)=>({
  start: (i/segments)*Math.PI*2,
  length: (Math.PI*2/segments)*(0.45+Math.random()*0.4),
  drift: Math.random()*Math.PI*2
}));

/* ───────── PARTICLES (FROM BLINK) ───────── */
const particles = [];
function spawnBlinkParticles(){
  const count = 14 + Math.floor(Math.random()*8);
  for(let i=0;i<count;i++){
    particles.push({
      x: eye.x + (Math.random()-0.5)*16,
      y: eye.y + (Math.random()-0.5)*6,
      vx: (Math.random()-0.5)*0.12,
      vy: 0.06 + Math.random()*0.08,
      r: 14 + Math.random()*20,
      a: 0.1,
      life: 1
    });
  }
}

function drawParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life *= 0.97;
    p.x += p.vx + Math.sin(p.y*0.02 + T)*0.04;
    p.y += p.vy;

    ctx.fillStyle = `rgba(120,255,180,${p.a*p.life})`;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2);
    ctx.fill();

    if(p.life<0.04 || p.y>h+60) particles.splice(i,1);
  }
}

/* ───────── INNER EYE DEPTH ───────── */
function drawEyeGlow(){
  ctx.save();
  ctx.translate(eye.x, eye.y);

  const pulse = eye.blink;

  // dark core
  ctx.fillStyle = "rgba(10,30,20,0.6)";
  ctx.scale(1.2*pulse,0.6*pulse);
  ctx.beginPath();
  ctx.arc(0,0,18,0,Math.PI*2);
  ctx.fill();

  // luminous edge
  const g = ctx.createRadialGradient(0,0,10,0,0,48);
  g.addColorStop(0,"rgba(120,255,180,0.0)");
  g.addColorStop(0.6,"rgba(120,255,180,0.18)");
  g.addColorStop(1,"rgba(120,255,180,0.0)");
  ctx.fillStyle = g;

  ctx.scale(1.3,1.2);
  ctx.beginPath();
  ctx.arc(0,0,32,0,Math.PI*2);
  ctx.fill();

  ctx.restore();
}

/* ───────── RING (PRIMARY MOTION) ───────── */
function drawRing(){
  ctx.save();
  ctx.translate(eye.x, eye.y);

  const breathe = Math.sin(T*0.6)*6;
  const twist = Math.sin(T*0.35)*0.18;
  ctx.rotate(twist);

  fractures.forEach((f,i)=>{
    f.drift += 0.002;
    ctx.beginPath();
    ctx.arc(
      0,0,
      eye.radius + breathe + Math.sin(f.drift+i)*1.5,
      f.start,
      f.start + f.length
    );
    ctx.strokeStyle = "rgba(120,255,180,0.45)";
    ctx.lineWidth = 2;
    ctx.shadowColor = "rgba(120,255,180,0.3)";
    ctx.shadowBlur = 12;
    ctx.stroke();
  });

  ctx.restore();
}

/* ───────── VIGNETTE (ANCHORS IT) ───────── */
function drawVignette(){
  const g = ctx.createRadialGradient(
    w/2,h/2,Math.min(w,h)*0.3,
    w/2,h/2,Math.max(w,h)*0.7
  );
  g.addColorStop(0,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,0.35)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

/* ───────── LOOP ───────── */
function loop(){
  ctx.clearRect(0,0,w,h);
  T += 0.003;

  // blink timing
  if(performance.now()>eye.nextBlink && eye.blinkTarget===1){
    eye.blinkTarget=0;
    spawnBlinkParticles();
  }
  if(eye.blinkTarget===0 && eye.blink<0.05){
    eye.blinkTarget=1;
    eye.nextBlink=performance.now()+6000+Math.random()*6000;
  }
  eye.blink += (eye.blinkTarget-eye.blink)*0.08;

  drawParticles();
  drawEyeGlow();
  drawRing();
  drawVignette();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
